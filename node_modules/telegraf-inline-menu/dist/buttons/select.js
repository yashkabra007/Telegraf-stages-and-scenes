"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const prefix_1 = require("../prefix");
const align_1 = require("./align");
function generateSelectButtons(actionBase, options, selectOptions) {
    const { textFunc, hide, columns, maxRows, currentPage } = selectOptions;
    const buttons = options.map((key, i, arr) => {
        const action = `${actionBase}-${key}`;
        const textKey = (ctx) => __awaiter(this, void 0, void 0, function* () { return textFunc(ctx, key, i, arr); });
        const hideKey = (ctx) => __awaiter(this, void 0, void 0, function* () { return hide ? hide(ctx, key) : false; });
        return {
            text: textKey,
            action,
            hide: hideKey
        };
    });
    return align_1.getRowsOfButtons(buttons, columns, maxRows, currentPage);
}
exports.generateSelectButtons = generateSelectButtons;
function selectButtonCreator(action, optionsFunc, additionalArgs) {
    const { getCurrentPage, textFunc, prefixFunc, isSetFunc, multiselect } = additionalArgs;
    return (ctx) => __awaiter(this, void 0, void 0, function* () {
        const optionsResult = yield optionsFunc(ctx);
        const keys = Array.isArray(optionsResult) ? optionsResult : Object.keys(optionsResult);
        const currentPage = getCurrentPage ? yield getCurrentPage(ctx) : 1;
        const fallbackKeyTextFunc = Array.isArray(optionsResult) ?
            (_ctx, key) => key :
            (_ctx, key) => optionsResult[key];
        const textOnlyFunc = textFunc || fallbackKeyTextFunc;
        const keyTextFunc = (...args) => __awaiter(this, void 0, void 0, function* () {
            return prefix_1.prefixEmoji(textOnlyFunc, prefixFunc || isSetFunc, Object.assign({ hideFalseEmoji: !multiselect }, additionalArgs), ...args);
        });
        return generateSelectButtons(action, keys, Object.assign({}, additionalArgs, { textFunc: keyTextFunc, currentPage }));
    });
}
exports.selectButtonCreator = selectButtonCreator;
function selectHideFunc(keyFromCtx, optionsFunc, userHideFunc) {
    return (ctx) => __awaiter(this, void 0, void 0, function* () {
        const key = keyFromCtx(ctx);
        const optionsResult = yield optionsFunc(ctx);
        const keys = Array.isArray(optionsResult) ? optionsResult : Object.keys(optionsResult);
        if (!keys.includes(key)) {
            return true;
        }
        if (userHideFunc && (yield userHideFunc(ctx, key))) {
            return true;
        }
        return false;
    });
}
exports.selectHideFunc = selectHideFunc;
//# sourceMappingURL=select.js.map